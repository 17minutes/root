// Helper class need to merge histograms and profiles 


// some helper functions
//______________________________________________________________________________
static inline Bool_t AlmostEqual(Double_t a, Double_t b, Double_t epsilon = 0.00000001)
{
   return TMath::Abs(a - b) < epsilon;
}

//______________________________________________________________________________
static inline Bool_t AlmostInteger(Double_t a, Double_t epsilon = 0.00000001)
{
   return AlmostEqual(a - TMath::Floor(a), 0, epsilon) ||
      AlmostEqual(a - TMath::Floor(a), 1, epsilon);
}

//______________________________________________________________________________
Bool_t TH1::SameLimitsAndNBins(const TAxis& axis1, const TAxis& axis2)
{
   // Same limits and bins.

   if ((axis1.GetNbins() == axis2.GetNbins())
      && (axis1.GetXmin() == axis2.GetXmin())
      && (axis1.GetXmax() == axis2.GetXmax()))
      return kTRUE;
   else
      return kFALSE;
}

static inline bool IsEquidistantBinning(const TAxis& axis)
{
   // check if axis bin are equals
   if (!axis.GetXbins()->fN) return true;  //  
   // not able to check if there is only one axis entry
   bool isEquidistant = true;
   const Double_t firstBinWidth = axis.GetBinWidth(1);
   for (int i = 1; i < axis.GetNbins(); ++i) {
      const Double_t binWidth = axis.GetBinWidth(i);
      const bool match = TMath::AreEqualRel(firstBinWidth, binWidth, TMath::Limits<Double_t>::Epsilon());
      isEquidistant &= match;
      if (!match)
         break;
   }
   return isEquidistant;
}

//______________________________________________________________________________
Bool_t TH1::RecomputeAxisLimits(TAxis& destAxis, const TAxis& anAxis)
{
   // Finds new limits for the axis for the Merge function.
   // returns false if the limits are incompatible
   if (SameLimitsAndNBins(destAxis, anAxis))
      return kTRUE;

   if (!IsEquidistantBinning(destAxis) || !IsEquidistantBinning(anAxis))
      return kFALSE;       // not equidistant user binning not supported

   Double_t width1 = destAxis.GetBinWidth(0);
   Double_t width2 = anAxis.GetBinWidth(0);
   if (width1 == 0 || width2 == 0)
      return kFALSE;       // no binning not supported

   Double_t xmin = TMath::Min(destAxis.GetXmin(), anAxis.GetXmin());
   Double_t xmax = TMath::Max(destAxis.GetXmax(), anAxis.GetXmax());
   Double_t width = TMath::Max(width1, width2);

   // check the bin size
   if (!AlmostInteger(width/width1) || !AlmostInteger(width/width2))
      return kFALSE;

   // std::cout << "Find new limit using given axis " << anAxis.GetXmin() << " , " <<  anAxis.GetXmax() << " bin width " << width2 << std::endl;
   // std::cout << "           and destination axis " << destAxis.GetXmin() << " , " <<  destAxis.GetXmax() << " bin width " << width1 << std::endl;


   // check the limits
   Double_t delta;
   delta = (destAxis.GetXmin() - xmin)/width1;
   if (!AlmostInteger(delta))
      xmin -= (TMath::Ceil(delta) - delta)*width1;

   delta = (anAxis.GetXmin() - xmin)/width2;
   if (!AlmostInteger(delta))
      xmin -= (TMath::Ceil(delta) - delta)*width2;


   delta = (destAxis.GetXmin() - xmin)/width1;
   if (!AlmostInteger(delta))
      return kFALSE;


   delta = (xmax - destAxis.GetXmax())/width1;
   if (!AlmostInteger(delta))
      xmax += (TMath::Ceil(delta) - delta)*width1;


   delta = (xmax - anAxis.GetXmax())/width2;
   if (!AlmostInteger(delta))
      xmax += (TMath::Ceil(delta) - delta)*width2;


   delta = (xmax - destAxis.GetXmax())/width1;
   if (!AlmostInteger(delta))
      return kFALSE;
#ifdef DEBUG
   if (!AlmostInteger((xmax - xmin) / width)) {   // unnecessary check
      printf("TH1::RecomputeAxisLimits - Impossible\n");
      return kFALSE;
   }
#endif


   destAxis.Set(TMath::Nint((xmax - xmin)/width), xmin, xmax);

   //std::cout << "New re-computed axis : [ " << xmin << " , " << xmax << " ] width = " << width << " nbins " << destAxis.GetNbins() << std::endl;
   
   return kTRUE;
}


// merge function for 1D histograms

//______________________________________________________________________________
Long64_t TH1::Merge(TCollection *li)
{
   // Add all histograms in the collection to this histogram.
   // This function computes the min/max for the x axis,
   // compute a new number of bins, if necessary,
   // add bin contents, errors and statistics.
   // If all histograms have bin labels, bins with identical labels
   // will be merged, no matter what their order is.
   // If overflows are present and limits are different the function will fail.
   // The function returns the total number of entries in the result histogram
   // if the merge is successful, -1 otherwise.
   //
   // IMPORTANT remark. The axis x may have different number
   // of bins and different limits, BUT the largest bin width must be
   // a multiple of the smallest bin width and the upper limit must also
   // be a multiple of the bin width.
   // Example:
   // void atest() {
   //    TH1F *h1 = new TH1F("h1","h1",110,-110,0);
   //    TH1F *h2 = new TH1F("h2","h2",220,0,110);
   //    TH1F *h3 = new TH1F("h3","h3",330,-55,55);
   //    TRandom r;
   //    for (Int_t i=0;i<10000;i++) {
   //       h1->Fill(r.Gaus(-55,10));
   //       h2->Fill(r.Gaus(55,10));
   //       h3->Fill(r.Gaus(0,10));
   //    }
   //
   //    TList *list = new TList;
   //    list->Add(h1);
   //    list->Add(h2);
   //    list->Add(h3);
   //    TH1F *h = (TH1F*)h1->Clone("h");
   //    h->Reset();
   //    h->Merge(list);
   //    h->Draw();
   // }

   if (!li) return 0;
   if (li->IsEmpty()) return (Long64_t) GetEntries();

   // is this really needed ?
   TList inlist;
   inlist.AddAll(li);


   TAxis newXAxis;

   Bool_t initialLimitsFound = kFALSE;
   Bool_t allHaveLabels = kTRUE;  // assume all histo have labels and check later
   Bool_t allHaveLimits = kTRUE;
   Bool_t allSameLimits = kTRUE;
   Bool_t foundLabelHist = kFALSE;
   //Bool_t firstHistWithLimits = kTRUE;


   TIter next(&inlist);
   // start looping with this histogram
   TH1 * h = this;

   do  {
      // do not skip anymore empty histograms 
      // since are used to set the limits 
      Bool_t hasLimits = h->GetXaxis()->GetXmin() < h->GetXaxis()->GetXmax();
      allHaveLimits = allHaveLimits && hasLimits;

      if (hasLimits) {
         h->BufferEmpty();

         // this is done in case the first histograms are empty and
         // the histogram have different limits
#ifdef LATER
         if (firstHistWithLimits ) {
            // set axis limits in the case the first histogram did not have limits 
            if (h != this && !SameLimitsAndNBins( fXaxis, *h->GetXaxis()) ) {
              if (h->GetXaxis()->GetXbins()->GetSize() != 0) fXaxis.Set(h->GetXaxis()->GetNbins(), h->GetXaxis()->GetXbins()->GetArray());
              else                                           fXaxis.Set(h->GetXaxis()->GetNbins(), h->GetXaxis()->GetXmin(), h->GetXaxis()->GetXmax());
            }
            firstHistWithLimits = kFALSE;
         }
#endif

         // this is executed the first time an histogram with limits is found
         // to set some initial values on the new axis
         if (!initialLimitsFound) {
            initialLimitsFound = kTRUE;
            if (h->GetXaxis()->GetXbins()->GetSize() != 0) newXAxis.Set(h->GetXaxis()->GetNbins(), h->GetXaxis()->GetXbins()->GetArray());
            else                                           newXAxis.Set(h->GetXaxis()->GetNbins(), h->GetXaxis()->GetXmin(), h->GetXaxis()->GetXmax());
         }
         else {
            // check first if histograms have same bins
            if (!SameLimitsAndNBins(newXAxis, *(h->GetXaxis())) ) {
               allSameLimits = kFALSE;
               // recompute the limits in this case the optimal limits
               // The condition to works is that the histogram have same bin with
               // and one common bin edge
               if (!RecomputeAxisLimits(newXAxis, *(h->GetXaxis()))) {
                  Error("Merge", "Cannot merge histograms - limits are inconsistent:\n "
                        "first: (%d, %f, %f), second: (%d, %f, %f)",
                        newXAxis.GetNbins(), newXAxis.GetXmin(), newXAxis.GetXmax(),
                        h->GetXaxis()->GetNbins(), h->GetXaxis()->GetXmin(),
                        h->GetXaxis()->GetXmax());
                  return -1;
               }
            }
         }
      }
      if (allHaveLabels) {
         THashList* hlabels=h->GetXaxis()->GetLabels();
         Bool_t haveOneLabel = (hlabels != 0);
         // do here to print message only one time
         if (foundLabelHist && allHaveLabels && !haveOneLabel) {
            Warning("Merge","Not all histograms have labels. I will ignore labels,"
            " falling back to bin numbering mode.");
         }

         allHaveLabels &= (haveOneLabel);
         // for the error message
         if (haveOneLabel) foundLabelHist = kTRUE;
         // I could add a check if histogram contains bins without a label
         // and with non-zero bin content
         // Do we want to support this ???
         // only in case the kCanRebin bit is not set
         if (allHaveLabels && !h->TestBit(TH1::kCanRebin) ) {
            // count number of bins with non-null content
            Int_t non_zero_bins = 0;
            Int_t nbins = h->GetXaxis()->GetNbins();
            if (nbins > hlabels->GetEntries() ) {
               for (Int_t i = 1; i <= nbins; i++) {
                  if (h->GetBinContent(i) != 0 || (fSumw2.fN && h->GetBinError(i) != 0) ) {
                     non_zero_bins++;
                  }
               }
               if (non_zero_bins > hlabels->GetEntries() ) {
                  Warning("Merge","Histogram %s contains non-empty bins without labels - falling back to bin numbering mode",h->GetName() );
                  allHaveLabels = kFALSE;
               }
            }
         }
      }
   }    while ( ( h = dynamic_cast<TH1*> ( next() ) ) != NULL );

   if (!h && (*next) ) {
      Error("Merge","Attempt to merge object of class: %s to a %s",
            (*next)->ClassName(),this->ClassName());
      return -1;
   }


   next.Reset();
   // In the case of histogram with different limits
   // newXAxis will now have the new found limits
   // but one needs first to clone this histogram to perform the merge
   // The clone is not needed when all histograms have the same limits
   TH1 * hclone = 0;
   if (!allSameLimits) {
      // We don't want to add the clone to gDirectory,
      // so remove our kMustCleanup bit temporarily
      Bool_t mustCleanup = TestBit(kMustCleanup);
      if (mustCleanup) ResetBit(kMustCleanup);
      hclone = (TH1*)IsA()->New();
      hclone->SetDirectory(0);
      Copy(*hclone);
      if (mustCleanup) SetBit(kMustCleanup);
      BufferEmpty(1);         // To remove buffer.
      Reset();                // BufferEmpty sets limits so we can't use it later.
      SetEntries(0);
      inlist.AddFirst(hclone);
   }

   // set the binning and cell content on the histogram to merge when the histograms do not have the same binning 
   // and when one of the histogram does not have limits
   if (initialLimitsFound && (!allSameLimits || !allHaveLimits )) {
     if (newXAxis.GetXbins()->GetSize() != 0) SetBins(newXAxis.GetNbins(), newXAxis.GetXbins()->GetArray());
     else                                     SetBins(newXAxis.GetNbins(), newXAxis.GetXmin(), newXAxis.GetXmax());
   }

   // std::cout << "Merging on histogram " << GetName() << std::endl;
   // std::cout << "Merging flags : allHaveLimits - allHaveLabels - initialLimitsFound - allSameLimits " << std::endl;
   // std::cout << "                 " << allHaveLimits << "\t\t" << allHaveLabels << "\t\t" <<  initialLimitsFound << "\t\t" <<  allSameLimits << std::endl;


   if (!allHaveLimits && !allHaveLabels) {
      // fill this histogram with all the data from buffers of histograms without limits
      while (TH1* hist = (TH1*)next()) {
         // support also case where some histogram have limits and some have the buffer
         if ( (hist->GetXaxis()->GetXmin() >= hist->GetXaxis()->GetXmax() ) && hist->fBuffer  ) {
            // no limits
            Int_t nbentries = (Int_t)hist->fBuffer[0];
            for (Int_t i = 0; i < nbentries; i++)
               Fill(hist->fBuffer[2*i + 2], hist->fBuffer[2*i + 1]);
            // Entries from buffers have to be filled one by one
            // because FillN doesn't resize histograms.
         }
      }

      // all histograms have been processed
      if (!initialLimitsFound ) {
         // here the case where all histograms don't have limits
         // In principle I should not have copied in hclone since
         // when initialLimitsFound = false then allSameLimits should be  true
         if (hclone) {
            inlist.Remove(hclone);
            delete hclone;
         }
         return (Long64_t) GetEntries();
      }

      // In case some of the histograms do not have limits 
      // I need to remove the buffer 
      if (fBuffer) BufferEmpty(1); 

      next.Reset();
   }

   //merge bin contents and errors
   // in case when histogram have limits

   Double_t stats[kNstat], totstats[kNstat];
   for (Int_t i=0;i<kNstat;i++) {totstats[i] = stats[i] = 0;}
   GetStats(totstats);
   Double_t nentries = GetEntries();
   Bool_t canRebin=TestBit(kCanRebin);
   // reset, otherwise setting the under/overflow will rebin and make a mess
   if (!allHaveLabels) ResetBit(kCanRebin);
   while (TH1* hist=(TH1*)next()) {
      // process only if the histogram has limits; otherwise it was processed before      
      // in the case of an existing buffer (see if statement just before)

      //std::cout << "merging histogram " << GetName() << " with " << hist->GetName() << std::endl;

      // skip empty histograms 
      Double_t histEntries = hist->GetEntries();
      if (hist->fTsumw == 0 && histEntries == 0) continue;


      // merge for labels or histogram with limits 
      if (allHaveLabels || (hist->GetXaxis()->GetXmin() < hist->GetXaxis()->GetXmax()) ) {
         // import statistics
         hist->GetStats(stats);
         for (Int_t i=0;i<kNstat;i++)
            totstats[i] += stats[i];
         nentries += histEntries;


         Int_t nx = hist->GetXaxis()->GetNbins();
         // loop on bins of the histogram and do the merge
         for (Int_t binx = 0; binx <= nx + 1; binx++) {
            Double_t cu = hist->GetBinContent(binx);
            Double_t error1 = 0;
            Int_t ix = -1;
            if (fSumw2.fN) error1= hist->GetBinError(binx);
            // do only for bins with non null bin content or non-null errors (if Sumw2)
            if (TMath::Abs(cu) > 0 || (fSumw2.fN && error1 > 0 ) ) {
               // case  of overflow bins
               // they do not make sense also in the case of labels
               if (!allHaveLabels) {
                  // case of bins without labels
                  if (!allSameLimits)  {
                     if ( binx==0 || binx== nx+1) {
                        Error("Merge", "Cannot merge histograms - the histograms have"
                              " different limits and undeflows/overflows are present."
                              " The initial histogram is now broken!");
                        return -1;
                     }
                     // NOTE: in the case of one of the histogram  as labels - it is treated as
                     // an error and it has been flagged before
                     // since calling FindBin(x) for histo with labels does not make sense
                     // and the result is unpredictable
                     ix = fXaxis.FindBin(hist->GetXaxis()->GetBinCenter(binx));
                  }
                  else {
                     // histogram have same limits - no need to call FindBin
                     ix = binx;
                  }
               } else {
                  // here only in the case of bins with labels
                  const char* label=hist->GetXaxis()->GetBinLabel(binx);
                  // do we need to support case when there are bins with labels and bins without them ??
                  // NO -then return an error
                  if (label == 0 ) {
                     Fatal("Merge","Histogram %s with labels has NULL label pointer for bin %d",
                           hist->GetName(),binx );
                     return -1;
                  }
                  if (label[0] == 0 ) { // case label is "" , i.e. is not set
                     // exclude underflow which could contain the non-existing labels
                     // thsi we could merge in all underflow
                     if ( binx > 0 && binx <= nx) {
                        Error("Merge","Cannot merge ! Label histogram %s contains a bin %d which has not a label and has non-zero content ",hist->GetName(),binx );
                        return -1;
                     }
                     else
                        // case of underflow/overflow
                        ix = binx;
                  }
                  else {
                     // if bin does not exists FindBin will add it automatically
                     // by calling LabelsInflate() if the bit is set
                     // otherwise it will return zero and bin will be merged in underflow/overflow
                     // Do we want to keep this case ??
                     ix = fXaxis.FindBin(label);
                  }
                  // ix cannot be -1 . Can be 0 in case label is not found and bit is not set
                  if (ix <0) {
                     Fatal("Merge","Error return from TAxis::FindBin for label %s",label);
                     return -1;
                  }
               }
               if (ix >= 0) {
                  // MERGE here the bin contents
                  //std::cout << "merging bin " << binx << " into " << ix << " with bin content " << cu << " bin center x = " << GetBinCenter(ix) << std::endl;
                  if (ix > fNcells )
                     Fatal("Merge","Fatal error merging histogram %s - bin number is %d and array size is %d",GetName(), ix,fNcells); 

                  AddBinContent(ix,cu);
                  if (fSumw2.fN)  fSumw2.fArray[ix] += error1*error1;
               }
            }
         }
      }
   }
   if (canRebin) SetBit(kCanRebin);


   //copy merged stats
   PutStats(totstats);
   SetEntries(nentries);
   if (hclone) {
      inlist.Remove(hclone);
      delete hclone;
   }
   return (Long64_t)nentries;
}

//______________________________________________________________________________
Long64_t HistogramMerger::DoMerge(TH1 * h0, TCollection *li)
{
   /// Merge list of histogram li in this histogram h0
   /// and returns the total number of entries of the merge histogram. 
   /// It returns -1 is t emerge fails. 
   /// 
   /// If all the histogram in the list have the same bin content as h0 
   /// merge is straightforward
   /// If 

   // This function computes the min/max for the x axis,
   // compute a new number of bins, if necessary,
   // add bin contents, errors and statistics.
   // If all histograms have bin labels, bins with identical labels
   // will be merged, no matter what their order is.
   // If overflows are present and limits are different the function will fail.
   // The function returns the total number of entries in the result histogram
   // if the merge is successful, -1 otherwise.
   //
   // IMPORTANT remark. The axis x may have different number
   // of bins and different limits, BUT the largest bin width must be
   // a multiple of the smallest bin width and the upper limit must also
   // be a multiple of the bin width.
   // Example:
   // void atest() {
   //    TH1F *h1 = new TH1F("h1","h1",110,-110,0);
   //    TH1F *h2 = new TH1F("h2","h2",220,0,110);
   //    TH1F *h3 = new TH1F("h3","h3",330,-55,55);
   //    TRandom r;
   //    for (Int_t i=0;i<10000;i++) {
   //       h1->Fill(r.Gaus(-55,10));
   //       h2->Fill(r.Gaus(55,10));
   //       h3->Fill(r.Gaus(0,10));
   //    }
   //
   //    TList *list = new TList;
   //    list->Add(h1);
   //    list->Add(h2);
   //    list->Add(h3);
   //    TH1F *h = (TH1F*)h1->Clone("h");
   //    h->Reset();
   //    h->Merge(list);
   //    h->Draw();
   // }

   if (!li) return 0;
   if (li->IsEmpty()) return (Long64_t) GetEntries();

   // is this really needed ?
   TList inlist;
   inlist.AddAll(li);


   TAxis newXAxis;

   Bool_t initialLimitsFound = kFALSE;
   Bool_t allHaveLabels = kTRUE;  // assume all histo have labels and check later
   Bool_t allHaveLimits = kTRUE;
   Bool_t allSameLimits = kTRUE;
   Bool_t foundLabelHist = kFALSE;
   //Bool_t firstHistWithLimits = kTRUE;


   TIter next(&inlist);
   // start looping with this histogram
   TH1 * h = this;

   do  {
      // do not skip anymore empty histograms 
      // since are used to set the limits 
      Bool_t hasLimits = h->GetXaxis()->GetXmin() < h->GetXaxis()->GetXmax();
      allHaveLimits = allHaveLimits && hasLimits;

      if (hasLimits) {
         h->BufferEmpty();

         // this is done in case the first histograms are empty and
         // the histogram have different limits
#ifdef LATER
         if (firstHistWithLimits ) {
            // set axis limits in the case the first histogram did not have limits 
            if (h != this && !SameLimitsAndNBins( fXaxis, *h->GetXaxis()) ) {
              if (h->GetXaxis()->GetXbins()->GetSize() != 0) fXaxis.Set(h->GetXaxis()->GetNbins(), h->GetXaxis()->GetXbins()->GetArray());
              else                                           fXaxis.Set(h->GetXaxis()->GetNbins(), h->GetXaxis()->GetXmin(), h->GetXaxis()->GetXmax());
            }
            firstHistWithLimits = kFALSE;
         }
#endif

         // this is executed the first time an histogram with limits is found
         // to set some initial values on the new axis
         if (!initialLimitsFound) {
            initialLimitsFound = kTRUE;
            if (h->GetXaxis()->GetXbins()->GetSize() != 0) newXAxis.Set(h->GetXaxis()->GetNbins(), h->GetXaxis()->GetXbins()->GetArray());
            else                                           newXAxis.Set(h->GetXaxis()->GetNbins(), h->GetXaxis()->GetXmin(), h->GetXaxis()->GetXmax());
         }
         else {
            // check first if histograms have same bins
            if (!SameLimitsAndNBins(newXAxis, *(h->GetXaxis())) ) {
               allSameLimits = kFALSE;
               // recompute the limits in this case the optimal limits
               // The condition to works is that the histogram have same bin with
               // and one common bin edge
               if (!RecomputeAxisLimits(newXAxis, *(h->GetXaxis()))) {
                  Error("Merge", "Cannot merge histograms - limits are inconsistent:\n "
                        "first: (%d, %f, %f), second: (%d, %f, %f)",
                        newXAxis.GetNbins(), newXAxis.GetXmin(), newXAxis.GetXmax(),
                        h->GetXaxis()->GetNbins(), h->GetXaxis()->GetXmin(),
                        h->GetXaxis()->GetXmax());
                  return -1;
               }
            }
         }
      }
      if (allHaveLabels) {
         THashList* hlabels=h->GetXaxis()->GetLabels();
         Bool_t haveOneLabel = (hlabels != 0);
         // do here to print message only one time
         if (foundLabelHist && allHaveLabels && !haveOneLabel) {
            Warning("Merge","Not all histograms have labels. I will ignore labels,"
            " falling back to bin numbering mode.");
         }

         allHaveLabels &= (haveOneLabel);
         // for the error message
         if (haveOneLabel) foundLabelHist = kTRUE;
         // I could add a check if histogram contains bins without a label
         // and with non-zero bin content
         // Do we want to support this ???
         // only in case the kCanRebin bit is not set
         if (allHaveLabels && !h->TestBit(TH1::kCanRebin) ) {
            // count number of bins with non-null content
            Int_t non_zero_bins = 0;
            Int_t nbins = h->GetXaxis()->GetNbins();
            if (nbins > hlabels->GetEntries() ) {
               for (Int_t i = 1; i <= nbins; i++) {
                  if (h->GetBinContent(i) != 0 || (fSumw2.fN && h->GetBinError(i) != 0) ) {
                     non_zero_bins++;
                  }
               }
               if (non_zero_bins > hlabels->GetEntries() ) {
                  Warning("Merge","Histogram %s contains non-empty bins without labels - falling back to bin numbering mode",h->GetName() );
                  allHaveLabels = kFALSE;
               }
            }
         }
      }
   }    while ( ( h = dynamic_cast<TH1*> ( next() ) ) != NULL );

   if (!h && (*next) ) {
      Error("Merge","Attempt to merge object of class: %s to a %s",
            (*next)->ClassName(),this->ClassName());
      return -1;
   }


   next.Reset();
   // In the case of histogram with different limits
   // newXAxis will now have the new found limits
   // but one needs first to clone this histogram to perform the merge
   // The clone is not needed when all histograms have the same limits
   TH1 * hclone = 0;
   if (!allSameLimits) {
      // We don't want to add the clone to gDirectory,
      // so remove our kMustCleanup bit temporarily
      Bool_t mustCleanup = TestBit(kMustCleanup);
      if (mustCleanup) ResetBit(kMustCleanup);
      hclone = (TH1*)IsA()->New();
      hclone->SetDirectory(0);
      Copy(*hclone);
      if (mustCleanup) SetBit(kMustCleanup);
      BufferEmpty(1);         // To remove buffer.
      Reset();                // BufferEmpty sets limits so we can't use it later.
      SetEntries(0);
      inlist.AddFirst(hclone);
   }

   // set the binning and cell content on the histogram to merge when the histograms do not have the same binning 
   // and when one of the histogram does not have limits
   if (initialLimitsFound && (!allSameLimits || !allHaveLimits )) {
     if (newXAxis.GetXbins()->GetSize() != 0) SetBins(newXAxis.GetNbins(), newXAxis.GetXbins()->GetArray());
     else                                     SetBins(newXAxis.GetNbins(), newXAxis.GetXmin(), newXAxis.GetXmax());
   }

   // std::cout << "Merging on histogram " << GetName() << std::endl;
   // std::cout << "Merging flags : allHaveLimits - allHaveLabels - initialLimitsFound - allSameLimits " << std::endl;
   // std::cout << "                 " << allHaveLimits << "\t\t" << allHaveLabels << "\t\t" <<  initialLimitsFound << "\t\t" <<  allSameLimits << std::endl;


   if (!allHaveLimits && !allHaveLabels) {
      // fill this histogram with all the data from buffers of histograms without limits
      while (TH1* hist = (TH1*)next()) {
         // support also case where some histogram have limits and some have the buffer
         if ( (hist->GetXaxis()->GetXmin() >= hist->GetXaxis()->GetXmax() ) && hist->fBuffer  ) {
            // no limits
            Int_t nbentries = (Int_t)hist->fBuffer[0];
            for (Int_t i = 0; i < nbentries; i++)
               Fill(hist->fBuffer[2*i + 2], hist->fBuffer[2*i + 1]);
            // Entries from buffers have to be filled one by one
            // because FillN doesn't resize histograms.
         }
      }

      // all histograms have been processed
      if (!initialLimitsFound ) {
         // here the case where all histograms don't have limits
         // In principle I should not have copied in hclone since
         // when initialLimitsFound = false then allSameLimits should be  true
         if (hclone) {
            inlist.Remove(hclone);
            delete hclone;
         }
         return (Long64_t) GetEntries();
      }

      // In case some of the histograms do not have limits 
      // I need to remove the buffer 
      if (fBuffer) BufferEmpty(1); 

      next.Reset();
   }

   //merge bin contents and errors
   // in case when histogram have limits

   Double_t stats[kNstat], totstats[kNstat];
   for (Int_t i=0;i<kNstat;i++) {totstats[i] = stats[i] = 0;}
   GetStats(totstats);
   Double_t nentries = GetEntries();
   Bool_t canRebin=TestBit(kCanRebin);
   // reset, otherwise setting the under/overflow will rebin and make a mess
   if (!allHaveLabels) ResetBit(kCanRebin);
   while (TH1* hist=(TH1*)next()) {
      // process only if the histogram has limits; otherwise it was processed before      
      // in the case of an existing buffer (see if statement just before)

      //std::cout << "merging histogram " << GetName() << " with " << hist->GetName() << std::endl;

      // skip empty histograms 
      Double_t histEntries = hist->GetEntries();
      if (hist->fTsumw == 0 && histEntries == 0) continue;


      // merge for labels or histogram with limits 
      if (allHaveLabels || (hist->GetXaxis()->GetXmin() < hist->GetXaxis()->GetXmax()) ) {
         // import statistics
         hist->GetStats(stats);
         for (Int_t i=0;i<kNstat;i++)
            totstats[i] += stats[i];
         nentries += histEntries;


         Int_t nx = hist->GetXaxis()->GetNbins();
         // loop on bins of the histogram and do the merge
         for (Int_t binx = 0; binx <= nx + 1; binx++) {
            Double_t cu = hist->GetBinContent(binx);
            Double_t error1 = 0;
            Int_t ix = -1;
            if (fSumw2.fN) error1= hist->GetBinError(binx);
            // do only for bins with non null bin content or non-null errors (if Sumw2)
            if (TMath::Abs(cu) > 0 || (fSumw2.fN && error1 > 0 ) ) {
               // case  of overflow bins
               // they do not make sense also in the case of labels
               if (!allHaveLabels) {
                  // case of bins without labels
                  if (!allSameLimits)  {
                     if ( binx==0 || binx== nx+1) {
                        Error("Merge", "Cannot merge histograms - the histograms have"
                              " different limits and undeflows/overflows are present."
                              " The initial histogram is now broken!");
                        return -1;
                     }
                     // NOTE: in the case of one of the histogram  as labels - it is treated as
                     // an error and it has been flagged before
                     // since calling FindBin(x) for histo with labels does not make sense
                     // and the result is unpredictable
                     ix = fXaxis.FindBin(hist->GetXaxis()->GetBinCenter(binx));
                  }
                  else {
                     // histogram have same limits - no need to call FindBin
                     ix = binx;
                  }
               } else {
                  // here only in the case of bins with labels
                  const char* label=hist->GetXaxis()->GetBinLabel(binx);
                  // do we need to support case when there are bins with labels and bins without them ??
                  // NO -then return an error
                  if (label == 0 ) {
                     Fatal("Merge","Histogram %s with labels has NULL label pointer for bin %d",
                           hist->GetName(),binx );
                     return -1;
                  }
                  if (label[0] == 0 ) { // case label is "" , i.e. is not set
                     // exclude underflow which could contain the non-existing labels
                     // thsi we could merge in all underflow
                     if ( binx > 0 && binx <= nx) {
                        Error("Merge","Cannot merge ! Label histogram %s contains a bin %d which has not a label and has non-zero content ",hist->GetName(),binx );
                        return -1;
                     }
                     else
                        // case of underflow/overflow
                        ix = binx;
                  }
                  else {
                     // if bin does not exists FindBin will add it automatically
                     // by calling LabelsInflate() if the bit is set
                     // otherwise it will return zero and bin will be merged in underflow/overflow
                     // Do we want to keep this case ??
                     ix = fXaxis.FindBin(label);
                  }
                  // ix cannot be -1 . Can be 0 in case label is not found and bit is not set
                  if (ix <0) {
                     Fatal("Merge","Error return from TAxis::FindBin for label %s",label);
                     return -1;
                  }
               }
               if (ix >= 0) {
                  // MERGE here the bin contents
                  //std::cout << "merging bin " << binx << " into " << ix << " with bin content " << cu << " bin center x = " << GetBinCenter(ix) << std::endl;
                  if (ix > fNcells )
                     Fatal("Merge","Fatal error merging histogram %s - bin number is %d and array size is %d",GetName(), ix,fNcells); 

                  AddBinContent(ix,cu);
                  if (fSumw2.fN)  fSumw2.fArray[ix] += error1*error1;
               }
            }
         }
      }
   }
   if (canRebin) SetBit(kCanRebin);


   //copy merged stats
   PutStats(totstats);
   SetEntries(nentries);
   if (hclone) {
      inlist.Remove(hclone);
      delete hclone;
   }
   return (Long64_t)nentries;
}
